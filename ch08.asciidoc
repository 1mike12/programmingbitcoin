== Pay To Script Hash

So far, we've been doing single-key transactions, ones where only a single private key has to sign in order to disperse the funds. But what if we wanted something a little more complicated? A company that does $100 million in Bitcoin transactions might not want all of the funds in a single public key as that key can be stolen by an employee and all funds lost. What can we do?

The solution is multi-sig, or multiple signatures. This was built into Bitcoin from the beginning, but was a bit clunky at first and so it wasn't used. In fact, as we'll discover, it turns out Satoshi never really tested OP_CHECKMULTISIG as it has a very obvious off-by-one error. The bug has had to stay in the protocol as fixing it would require a hard fork.

=== Bare Multisig

Bare Multisig was the first attempt at creating a transaction that could be signed by multiple parties. To understand Bare Multisig, one must first understand the OP_CHECKMULTISIG operator. As discussed in Chapter X, Script has a lot of different OP codes, of which OP_CHECKMULTISIG is one. The operator consumes a lot of elements from the stack and returns whether or not a certain number of signatures are valid for this transaction.

# TODO diagram of OP_CHECKMULTISIG

Essentially, the elements consumed by OP_CHECKMULTISIG is supposed to be:

m, m different signatures, n, n different pubkeys.

Unfortunately, the OP code actually consumes 1 more element than the m+n+2 that it's supposed to. OP_CHECKMULTISIG consumes m+n+3, so the extra element is added in order to not cause a failure.

In essence, this OP code asks that m of n of the pubkeys sign. m can be less than or equal to n.

Bare multisig is a bit ugly, but it's very much functional. You can have m of n signatures required to release funds and there is plenty of utility in making outputs multisig, especially if you're a business. However, bare multisig suffers from a few problems:

1. First problem is the obviously long length of the output. A hypothetical bare multisig address has to encompass many different public keys and that makes it extremely long. Unlike p2pkh or even p2pk, these are not easily sent.

2. Second problem is that because the output is so long, it's rather taxing on node software. Nodes have to keep track of outputs that have not been spent, so keeping it ready and perhaps in memory is ideal. A large output is more expensive to keep in memory, being 5-20x larger than a normal p2pkh output.

3. Third problem is that because the output can't be verified easily, bare multisig can and has been abused. The entire pdf of the original whitepaper is actually encoded in this transaction: 54e48e5f5c656b26c3bca14a8c95aa583d07ebe84dde3b7dd4a78f4e4186e713. The creator of this transaction actually split up the whitepaper pdf into 64 byte chunks which were then made into uncompressed public keys. Nevermind that these are not valid points, the actual whitepaper was encoded into 947 outputs as 1 of 3 outputs. The outputs are not spendable but have to be kept around by all the node software and is in that sense very abusive.

In order to combat these problems, 