[[chapter_base58]]
=== Base58

At this point, you may think that communicating our public keys via SEC format and signing transactions to have other nodes on the network verifying these transactions with the public key would be enough. Indeed that's what happened in the early days of Bitcoin. Bitcoins were assigned to Public Keys specified in SEC format (uncompressed) and then were redeemed using DER signatures. For reasons we'll get to in Chapter 6 (Script), this turned out to be both wasteful and less secure than what we use now. In this chapter, we'll go through what addresses are and how they are encoded.

==== Transmitting your Public Key

In order for Alice to effectively pay Bob, she has to know where to send Bob the money. This is true not just in Bitcoin, but any medium of exchange. Since Bitcoin is digital, the address can be something like a public key in a public key cryptography scheme. Unfortunately, SEC format, especially uncompressed is a bit long (65 or 33 bytes). Furthermore, the 65 or 33 bytes are in binary format, not something that's easy to read, at least raw.

There are two major considerations. The first is that the public key be readable (easy to write down or even say over the phone) and short (not be so long that it's cumbersome).

So how do we get both readability and compression? If we express the SEC format in hexadecimal (4 bits per character), it's actually double the length (130 or 66 bytes). Can we do better?

We can use something like Base64 which can express 6 bits per character and becomes 87 or 44 bytes. Unfortunately, Base64 is prone to mistakes as a lot of letters and numbers look similar (0 and O, l and I, - and _). If we remove these characters, we can have something that's got good readability and decent compression (around 5.86 bits per character).

This is called Base58. Instead of hexadecimal (base 16) or Base64, we're going to have to encode numbers in Base58.

TODO: sidebar - base58

==== Address Format

Here is how the Address format is created:

1. For mainnet addresses, start with the prefix 0x00, for testnet 0x6f
2. Take the SEC format (compressed or uncompressed) and do a SHA256 operation followed by the RIPEMD160 hash operation.
3. combine the prefix from #1 and resulting hash from #2
4. Do a double SHA256 of the result from #3 and get the first 4 bytes.
5. Take the combination of #3 and #4 and encode in Base58.

Step 4 of this process is called the checksum. We can do steps 4 and 5 in one go this way:

[source,python]
----
import hashlib

def double_sha256(s):
    return hashlib.sha256(hashlib.sha256(s).digest()).digest()
    
def encode_base58_checksum(s):
    return encode_base58(s + double_sha256(s)[:4]).decode('ascii')
----

The process of doing a SHA256 operation followed by a RIPEMD160 operation is called a HASH160 operation in Bitcoin. We can implement this fairly easily in helper.py..

[source,python]
----
import hashlib

def hash160(s):
    return hashlib.new('ripemd160', hashlib.sha256(s).digest()).digest()
----

We can also 

Now we can update S256Point to have the address method.

[source,python]
----
class S256Point:
...
    def h160(self, compressed=True):
        return hash160(self.sec(compressed))

    def address(self, compressed=True, prefix=b'\x00'):
        '''Returns the address string'''
        h160 = self.h160(compressed)
        return encode_base58_checksum(prefix + h160)

----

==== WIF Format

The Private Key in our case is a 256-bit number. Generally, you are not going to need to serialize your secret that often as it doesn't get broadcast (that would be a bad idea!). That said, there are instances where you may want to transfer your private key from one wallet to another.

For this purpose, there is a format called WIF, which stands for Wallet Import Format. WIF is a serialization of the private key that's meant to be human-readable. WIF specifically utilizes something called Base58 encoding which we'll also be utilizing for address generation.

Here is how the WIF format is created:

1. For mainnet private keys, start with the prefix 0x80, for testnet 0xef
2. Encode the secret in 32-byte big-endian.
3. If the sec format used for the public key address was compressed add a suffix of 0x01. 
4. Combine the prefix from #1, serialized secret from #2 and suffix from #3
5. Do a double SHA256 of the result from #4 and get the first 4 bytes.
6. Take the combination of #4 and #5 and encode in Base58.
 
We can now create the wif method on the PrivateKey class.

[source,python]
----
    def wif(self, testnet=False):
        if testnet:
            prefix = b'\xef'
        else:
            prefix = b'\x80'
        # convert the secret from integer to a 32-bytes in big endian using
        # num.to_bytes(32, 'big')
        secret_bytes = self.secret.to_bytes(32, 'big')
        # append b'\x01' if compressed
        if self.compressed:
            suffix = b'\x01'
        else:
            suffix = b''
        # encode_base58_checksum the whole thing
        return encode_base58_checksum(prefix + secret_bytes + suffix)
----